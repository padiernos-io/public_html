<?php
/**
 * @file
 */

use Drupal\user\Entity\User;
use Drupal\user\UserInterface;
use Drupal\Core\Session\AccountInterface;

/**
 * Implements hook_help().
 */
function alt_login_help($route_name, $route_match) {
  if ($route_name == 'help.page.alt_login') {
    return t("Allows login with various aliases, and formats the user's display name.");
  }
}

/**
 * Implements hook_entity_base_field_info_alter().
 * Remove the UserName constraint from the user entity, which makes the user->name a required field.
 */
function __alt_login_entity_base_field_info_alter(&$fields, $entity_type) {
  if ($entity_type->id() === 'user') {
    if (!alt_login_user_name_used()) {
      // Get the current constraints from the field.
      $constraints = $fields['name']->getConstraints();
      // Remove the 'UserName' constraint.
      unset($constraints['UserName']);
      // Apply the modified constraints back to the field.
      $fields['name']->addConstraints($constraints);
    }
  }
}

/**
 * Implements hook_user_format_name_alter().
 *
 * Manipulate the user display name according to settings. Since results of this
 * hook aren't cached, a static reduces calls to the token system.
 *
 * @note there's no easy way to dedupe accounts' display names.
 */
function alt_login_user_format_name_alter(&$name, AccountInterface $account) {
  if ($account->isAnonymous()) {
    // This will be the configured 'anonymous' value
    return;
  }
  static $names = [];
  $uid = $account->id();
  if (!isset($names[$uid])) {
    // Anonymous users
    if (\Drupal::currentUser()->isAnonymous()) {
      $anon = \Drupal::config('alt_login.settings')->get('display_anon');
      $names[$uid] = \Drupal::token()
        ->replace($anon, ['user' => $account], ['clear' => true]);
    }
    // Do the replacement if the module is configured.
    elseif ($template = \Drupal::config('alt_login.settings')->get('display')) {
      $user = $account instanceOf UserInterface ? $account : User::load($uid);
      $names[$uid] = \Drupal::token()->replace(
        $template,
        ['user' => $user],
        ['clear' => TRUE]
      );
    }
    // If the above didn't produce a string, fall back to the username.
    if (!isset($names[$uid]) or empty(trim($names[$uid]))) {
      $names[$uid] = $account->getAccountName();
    }
  }
  $name = $names[$uid];
}

/**
 * Implements hook_module_implements_alter().
 *
 * Ensure that this is the last module to format the username.
 */
function alt_login_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'user_format_name_alter') {
    unset($implementations['alt_login']);
    $implementations['alt_login'] = FALSE;
  }
}

function alt_login_user_name_used() : bool {
  $active = \Drupal::service('alt_login.method_manager')->activePlugins();
  return isset($active['username']);
}

/**
 * Implements hook_form_user_form_alter().
 */
function alt_login_form_user_form_alter(&$form, $form_state) {
  $user = $form_state->getFormObject()->getEntity();
  $user_aliases = alt_login_get_user_aliases($user);
  $namefield = &$form['account']['name'];
  $namefield['#description'] = t('This is the usual way to log in.');
  if (!alt_login_user_name_used()) {
    // Since the username is not used for logging in, it is not used at all.
    $namefield['#access'] = FALSE;
    if ($user->isNew()) {
      // Populate the name field with the email address which is sure to be unique
      $form['#entity_builders'][] = 'alt_login_entity_builder';
    }
    elseif (count($user_aliases) == 1) {
      $labels = \Drupal::service('alt_login.method_manager')->getActiveLabels();
      $namefield = [
        '#type' => 'markup',
        '#markup' => t(
          "N.B. Login with your %type, i.e. '%name'",
          ['%name' => reset($user_aliases), '%type' => reset($labels)]
        ),
        '#weight' => -1
      ];
    }
    else {
      $form['account']['aliases'] = [
        '#title' => t('Log in with any of'),
        '#theme' => 'item_list',
        '#items' => $user_aliases,
        '#weight' => -1
      ];
    }
    // This will populate the namefield which is now both hidden and required.
  }
  else {// Add a helpful description to the username field.
    unset($user_aliases['username']);
    if (count($user_aliases)) {
      $namefield['#description'] .= ' '. t('You can also login with: @alts', ['@alts' => implode(', ', $user_aliases)]);
    }
  }
  $form['account']['roles']['#weight'] = 2;
  $form['#validate'][] = 'alt_login_validate_dedupe_aliases';
}

/**
 * Implements hook_form_alter().
 */
function alt_login_form_alter(&$form, $form_state, $form_id) {
  $form_object = $form_state->getFormObject();
  if ($form_object instanceOf \Drupal\Core\Entity\EntityForm) {
    $user = $form_object->getEntity();
    // Show all the login options on the user form.
    if ($user instanceOf UserInterface) {
      //this is where function alt_login_form_user_form_alter() used to go
    }
  }
  // Add a validation callback to login fields to allow alternative login names
  else
    if (in_array($form_id, ['user_login_form', 'user_login_block'])) {
    $user_aliases = alt_login_get_user_aliases(User::load(0));
    $form['name']['#title'] = implode(', ', $user_aliases);
    unset($form['name']['#description']);
    $form['name']['#element_validate'][] = 'alt_login_login_name_element_validate';
  }
}

/**
 * Entity Builder callback for user entity.
 *
 * The username field was hidden on the user form so populate it with the email,
 * which is also unique. New user entities only.
 */
function alt_login_entity_builder($entity_type_id, $entity, $form, $form_state) {
  $entity->setUsername($entity->getEmail());
}

/**
 * Implements hook_user_presave().
 * @todo use the plugins to provide a default username when none is provided
 */
function alt_login_user_presave(UserInterface $account) {
  if ($account->isNew()) {
    // Awkwardly, users migrating in have isNew = true.
    if ($account->getCreatedTime() < Drupal::time()->getRequestTime()) {
      return;
    }
    // Contrive a username ensuring it is unique
    // use the first part of the email and extend with _1 in case of dupulicates.
    $login_aliases = \Drupal::Config('alt_login.settings')->get('aliases');
    if (!in_array('username', $login_aliases)) {
      $new_name = substr($account->getEmail(), 0, strpos($account->getEmail(), '@'));
      $lastname = \Drupal::database()->select('users_field_data', 'u')
        ->fields('u', ['name'])
        ->condition('name', "$new_name%", 'LIKE')
        ->range(0, 1)
        ->orderBy('name', 'DESC')
        ->execute()->fetchField();
      if ($lastname && preg_match('/^.*(_[0-9]+)*$/', $lastname, $matches)) {
        $inc=1;
        if (isset($matches[1])) {
          $inc = $matches[1]++;
        }
        $new_name .= '_'.$inc;
      }
      $account->setUsername($new_name);
      // Note that the the User RegisterForm logs user creation with another name.
    }
    // Construct the user->accountName from the address given and last names
    // N.B. this currently works on new users only, and does not enforce the value.
    elseif (in_array('address_name', $login_aliases)) {
      $address_field_name = \Drupal::service('alt_login.method_manager')->createInstance('address_name')->fieldName();
      if ($address = $account->{$address_field_name}->getValue()) {
        $givenname = isset($address[0]['given_name']) ? trim($address[0]['given_name']) : '';
        $familyname = isset($address[0]['family_name']) ? trim($address[0]['family_name']) : '';
        if ($new_name = trim($givenname .' '. $familyname)) {
          $account->setUsername($new_name);
        }
        else {
          \Drupal::service('logger.channel.alt_login')->error(t("Address name is required to set username."));
        }
      }
      else {
        \Drupal::service('logger.channel.alt_login')->error(t("Address field not found on user entity."));
      }
    }
    if (isset($new_name)) {
      \Drupal::service('logger.channel.alt_login')->notice(t('New username set to @name', ['@name' => $new_name]));
    }
  }
}


/**
 * Element validation callback for login form name field.
 *
 * Look up the real user name from the given login id and replace it ready for
 * the form-level validation.
 */
function alt_login_login_name_element_validate(&$element, $form_state) {
  $alt_name = alt_login_convert_alias($element['#value']);
  if (trim($alt_name)) {
    $form_state->setValue('name', $alt_name);
  }
}

/**
 * Utility
 *
 * Look up the given alias and return the username.
 *
 * @param string $alias
 *
 * @return string | NULL
 */
function alt_login_convert_alias($alias) : string {
  foreach (\Drupal::service('alt_login.method_manager')->activePlugins() as $plugin) {
    if ($plugin->applies($alias)) {
      if ($user = $plugin->getUserFromAlias($alias)) {
        return $user->getAccountName();
      }
    }
  }
  // ' ' is an invalid username which will not break the sql query.
  return ' ';
}

/**
 * Get all the alternative login strings for the given user
 *
 * @param Userinterface $user
 *
 * @return string[]
 *   user aliases keyed by the plugin name that produced them.
 */
function alt_login_get_user_aliases(UserInterface $user) {
  $alts = [];
  $method_manager = \Drupal::service('alt_login.method_manager');
  $active_plugins = $method_manager->activePlugins();
  if ($user->isAuthenticated()) {
    foreach ($active_plugins as $plugin_id => $plugin) {
      $alts[$plugin_id] = $plugin->getAlias($user);
    }
  }
  else {
    $labels = $method_manager->getOptions();
    foreach ($active_plugins as $plugin_id => $def) {
      $alts[$plugin_id] = $labels[$plugin_id];
    }
  }
  return $alts;
}

/**
 * Implements hook_tokens_alter().
 *
 * Replace the username with any aliases.
 */
function alt_login_tokens_alter(&$replacements, array $context, $bubbleable_metadata) {
  // For some reason the token module, if installed changes the $context
  if ($context['type'] == 'user' and isset($context['data']['user']) and isset($replacements['[user:name]'])) {
    $replacements['[user:name]'] = implode(t(' OR '), alt_login_get_user_aliases($context['data']['user']));
  }
  if ($context['type'] == 'entity' and isset($context['data']['entity']) and isset($replacements['[user:name]'])) {
    $replacements['[user:name]'] = implode(t(' OR '), alt_login_get_user_aliases($context['data']['user']));
  }
  //\Drupal::entityQuery('user')->condition('name', "$new_name%", 'LIKE')->accessCheck(FALSE)->execute();
}

/**
 * User form validation callback.
 */
function alt_login_validate_dedupe_aliases($form, $form_state) {
  $user = $form_state->getFormObject()->buildEntity($form, $form_state);
  foreach (\Drupal::service('alt_login.method_manager')->activePlugins() as $plugin) {
    if ($field_name = $plugin->dedupeAlias($user)) {
      $form_state->setErrorByName($field_name, t('This alias is already taken.'));
    }
  }
}

/**
 * Utility
 *
 * Could be useful for exporting.
 *
 * @param UserInterface $user
 * @param string $plugin_id
 *
 * @return string
 */
function alt_login_get_alias(UserInterface $user, $plugin_id) {
  return \Drupal::service('alt_login.method_manager')
    ->createInstance($plugin_id)
    ->getAlias($user);
}

/**
 * Get the descriptions from each of the plugins.
 * @return array
 */
function alt_login_active_descriptions() : array {
  $plugin_manager = \Drupal::service('alt_login.method_manager');
  foreach (\Drupal::Config('alt_login.settings')->get('aliases') as $plugin_id) {
    $def = $plugin_manager->getDefinition($plugin_id);
    $descriptions[] = $def['description'];
  }
  return $descriptions;
}
